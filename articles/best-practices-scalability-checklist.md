<properties
   pageTitle="可缩放性核对表 |Microsoft Azure"
   description="可伸缩性设计关注的 Azure 自动缩放清单指南。"
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="scalability-checklist"></a>可伸缩性核对清单

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="service-design"></a>服务设计
- **分区的工作负载**。 设计过程是离散和 decomposable 部分。 同时按照分离问题和单一责任原则的一般规则的每一个部分，大小最小化。 这使组件部分，以最大化每个计算单位 （如角色或数据库服务器) 的使用方式进行分发。 它还使容易通过添加特定资源的实例来扩展该应用程序。 有关详细信息，请参阅[计算分区指导](https://msdn.microsoft.com/library/dn589773.aspx)。
- **扩展的设计**。 缩放允许应用程序响应变量的负载增加和减少角色的实例的数量进行排队，并使用的其他服务。 但是，必须记住与此设计应用程序。 例如，应用程序和使用的服务必须是无状态的要允许请求路由到任何实例。 这样还可以防止的添加或删除的特定实例的不良影响当前用户。 您也应该实现配置或实例的自动检测添加和删除，以便在应用程序中的代码可以执行必要的路由。 例如，web 应用程序可能使用队列的集循环方法中可将请求路由到辅助角色中运行的后台服务。 Web 应用程序必须能够检测中的队列，成功地将请求路由和平衡应用程序负载数的变化。
- **作为一个单位的比例**。 规划以适应增长的其他资源。 对于每个资源，知道上限比例限制，并使用分片或分解超越这些限制。 确定根据良好定义的资源组的系统的度量单位。 这样应用扩展操作更方便且更少容易出现负面影响到整个系统的一些部件中带来的缺乏资源限制对应用程序。 例如，添加 x 数量的 web 和工作人员的角色可能需要附加队列的 y 数和 z 的存储帐户来处理额外的工作负荷生成的角色。 所以 x 的刻度单位无法包含 web 和员工角色、 _y_队列和_z_存储帐户。 设计应用程序，以便它轻松地扩展通过添加一个或多个刻度单位。
- **避免客户仿射性**。 如有可能，请确保应用程序不需要关系。 因此将请求路由到任何实例，并是不相关的实例数。 这也可以避免存储、 检索和维护每个用户的状态信息的开销。
- **利用平台自动缩放功能**。 其中托管平台支持自动缩放功能，如 Azure 自动缩放，它愿意自定义或第三方机制，除非内置的机制不能满足您的需求。 使用计划比例规则，以确保资源则无需启动延迟，但将反应性自动缩放添加到规则，在适当情况下应对需求的意外更改。 调整自动缩放，并向规则中添加自定义计数器，可以使用服务管理 API 中的自动缩放操作。 有关详细信息，请参阅[自动调整指南](best-practices-auto-scaling.md)。
- **减轻负担作为后台任务占用大量 CPU/IO 任务**。 对服务的请求需要花费很长时间运行或吸收大量的资源，如果卸载单独的任务对该请求的处理。 使用辅助角色或后台作业 （取决于主机平台） 来执行这些任务。 这种策略使服务能够继续进一步接收请求并保持响应状态。  有关详细信息，请参阅[后台作业指导](best-practices-background-jobs.md)。
- **对于后台任务的工作负载分布**。 有很多后台任务，或任务需要相当长的时间或资源，请将工作分摊到多个计算单位 （如辅助角色或后台作业）。 一个可能的解决方案，请参阅[竞争使用者模式](https://msdn.microsoft.com/library/dn568101.aspx)。
- **考虑朝着_无共享的_体系结构**。 无共享的体系结构使用独立、 自给自足的节点包含争用 （如共享的服务或存储） 消除单点。 从理论上讲，这样的系统可以几乎无限扩展。 尽管完全共享方法通常不是适用于大多数应用程序，它可能提供机会来实现更好的可扩展性设计。 例如，避免使用服务器端会话状态、 客户关系和数据分区是转向无共享的体系结构的典型示例。

## <a name="data-management"></a>数据管理

- **使用数据分区**。 在多个数据库和数据库服务器之间划分数据或应用程序使用的数据存储服务的设计可提供此分区以透明方式 （示例包括 Azure SQL 数据库弹性数据库和 Azure 表存储）。 这种方法可以帮助最大化性能，并允许更容易扩展。 有不同分区技术，例如，水平，垂直，并且工作正常。 可以使用这些项的组合，以获得最大好处提高了的查询性能、 较简单的可扩展性、 更灵活的管理、 更好的可用性，以及其所能容纳的数据存储区的类型相匹配。 另外，还要考虑针对不同类型的数据，选择基于如何更好地优化数据的特定类型的类型使用不同类型的数据存储区。 这可能包括使用表格存储、 文档数据库或列系列数据存储，而不是，或者同时为关系数据库。 有关详细信息，请参阅[数据分区指导](best-practices-data-partitioning.md)。
- **设计最终一致性**。 通过减少或删除同步相关的数据跨多个存储分区所需的时间，最终一致性提高了可扩展性。 成本是，数据并不总是一致时读取它，和一些写操作可能会导致冲突。 最终一致性是其中经常阅读但不经常写入相同的数据情况下的理想选择。 有关详细信息，请参阅[数据一致性的初级读本](https://msdn.microsoft.com/library/dn589800.aspx)。
- **减少吵闹的交互之间的组件和服务**。 避免应用程序需要进行多个调用到服务的交互设计 （其中每个返回的少量数据），而不是一次调用可返回的所有数据。 在可能的情况下，将调用到服务或组件具有明显延迟时合并成单个请求的几个相关的操作。 这使得更容易地监视性能和优化复杂的操作。 例如，在数据库中使用存储的过程来封装复杂的逻辑，并减少往返和资源锁定的数量。
- **使用队列级别的负载高速度的数据写操作**。 对服务的需求暴增可能会淹没该服务并导致不断提高故障。 若要防止出现这种情况，请考虑实现[基于队列的负载调配操作模式](https://msdn.microsoft.com/library/dn589783.aspx)。 使用队列，它就像一个任务和它所调用的服务之间的缓冲区。 这可使平滑间歇性否则可能导致服务失败或超时任务的繁重负载。
- **最小化数据存储区上的负载**。 数据存储区通常是处理瓶颈，昂贵的资源，且往往不容易向外扩展。 在可能的情况下，从数据存储中删除逻辑 （如处理 XML 文档或 JSON 对象） 和执行应用程序中的处理。 例如，传递到数据库 （而非作为不透明的字符串存储），XML 序列化或反序列化的 XML 应用程序层中并向其传递在窗体中，将数据存储到本机。 它是通常更容易扩张比的数据存储，该应用程序，因此应该尝试尽可能多的计算密集型处理应用程序内尽可能不要。
- **最小化数据量检索**。 只需要通过指定的列并使用条件来选择行的数据检索。 请使用表值参数的和适当的隔离级别。 使用机制，如实体标记，以避免不必要地检索数据。
- **积极地使用缓存**。 使用缓存尽可能减少资源和服务，生成或传递数据负载。 通常适合于相对静态的或者需要大量的处理，获得的数据进行缓存。 高速缓存应在所有级别在适当情况下在每一层的应用程序，包括数据访问和用户界面生成。 有关详细信息，请参阅[缓存指南](best-practices-caching.md)。
- **处理数据增长和保留**。 随着时间的推移由应用程序存储的数据量的增长。 这种增长增加了存储成本，并在访问数据时，会增加延迟--这会影响应用程序的吞吐量和性能。 它可能会定期存档某些不再访问旧的数据或将很少存取的数据移动到长期存储更经济有效，即使是更高的访问延迟。
- **优化数据传输对象 (Dto) 使用高效的二进制格式**。 很多时候 Dto 被传递应用程序的各层之间。 最小化大小减少了资源和网络上的负载。 但是，平衡与将数据转换为所需的格式，在每个位置使用它的系统开销的成本节约。 采用一种格式，具有最大的互操作性，可以方便地重复使用的组件。
- **设置缓存控制**。 设计和配置应用程序以使用输出缓存或片段缓存如有可能，尽量减少处理负载。
- **启用客户端缓存**。 Web 应用程序启用缓存设置可缓存的内容。 默认情况下通常禁用该功能。 配置服务器以提供适当的缓存控制标头以启用缓存代理服务器和客户端上的内容。
- **使用 Azure blob 存储和 Azure 内容交付网络，以减少对应用程序的负载**。 考虑存储 blob 存储静态或相对静态公共内容，如图像、 资源、 脚本和样式表。 这种方法缓解负荷引起的动态生成的每个请求该内容的应用程序。 此外，请考虑使用内容交付网络缓存此内容并将其发送给客户端。 使用内容交付网络可以提高在客户端的性能，因为在地理上最接近数据中心包含内容交付网络缓存从提交的内容。 有关详细信息，请参阅[内容交付网络指南](best-practices-cdn.md)。
- **优化和调整 SQL 查询和索引**。 一些 T SQL 语句或构造可能可以减少优化中的存储过程的代码的性能产生影响。 例如，应避免与**日期时间**文本值进行比较前将**datetime**类型转换为**varchar** 。 使用日期/时间比较函数来代替。 缺乏适当的索引可以降低查询的执行。 如果您使用一个对象/关系映射框架，了解它的工作原理，以及它如何可能影响性能的数据访问层。 有关详细信息，请参阅[优化查询](https://technet.microsoft.com/library/ms176005.aspx)。
- **考虑反规范化数据**。 数据规范化有助于避免重复和不一致。 但是，维护多个索引、 参照完整性检查、 执行多个较小的数据块，访问和连接表来重组数据会产生开销，可能会影响性能。 考虑一些额外的存储卷和消除是否可以接受，以减少数据存储区上的负载。 此外，考虑是否可以依赖应用程序本身 （这是通常很容易扩展） 来接管任务，如管理以减少数据存储区上的负载的参照完整性。 有关详细信息，请参阅[数据分区指导](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md)。

## <a name="service-implementation"></a>服务实现
- **使用异步调用**。 在访问资源或服务，可能会受 I/O 或网络带宽，或有明显的滞后时间，以避免锁定调用的线程时，尽可能使用异步代码。 若要实现异步操作，使用[基于任务的异步模式 （点击）](https://msdn.microsoft.com/library/hh873175.aspx)。
- **避免锁定资源，而改用一种乐观的方法**。 永远不会锁定访问资源如存储或其他服务的有明显的延迟，因为这是性能下降的主要原因。 始终使用开放式的方法来管理并行操作，如写入存储。 使用功能的存储层来管理冲突。 在分布式应用程序中，数据可能只有最终一致。
- **压缩通过高延迟、 低带宽的网络高度可压缩的数据**。 在大多数情况下，web 应用程序中，由应用程序生成，并通过网络传递的数据的最大卷为客户端请求的 HTTP 响应。 HTTP 压缩可以减少这得多，尤其是对静态内容。 尽管压缩动态内容不适用于分成几部分来高负载的服务器上，这样可以减少成本，以及减少在网络上的负荷。 在其他更多通用环境，数据压缩可以减少传输的数据量和最小化传输时间和成本，但压缩和解压缩过程开销。 在这种情况下，才应周密部署的政府提高性能时使用压缩。 其他序列化方法，例如 JSON 或二进制编码，可能会对性能的影响更少同时降低负载大小，而是可能会增加它的 XML。
- **最小化连接和资源都在使用的时间**。 只要您需要使用它们维护连接和资源只。 例如，打开连接越晚越好，并使他们能够尽快返回到连接池。 越晚越好，获取资源，并尽快处置资产。
- **所需最小化的连接数**。 服务连接吸收资源。 限制的需要，并确保尽可能重复使用现有连接的数量。 例如，在执行身份验证，使用模拟在适当情况下为某一特定标识运行代码。 这可通过重用连接使得充分利用连接池。

    > [AZURE.NOTE]: APIs for some services automatically reuse connections, provided service-specific guidelines are followed. It's important that you understand the conditions that enable connection reuse for each service that your application uses.

- **发送请求，分批来优化网络的使用**。 例如，发送访问队列时读取批处理中的邮件和访问存储或缓存时作为批处理执行多个读或写操作。 这可以帮助通过跨网络减少调用次数最大化服务和数据存储的效率。
- **避免将服务器端会话状态存储的要求**在可能的情况。 服务器端会话状态管理通常需要客户关系 （即，路由到相同的服务器实例的每个请求），这会影响系统的扩展能力。 理想情况下，您应该设计为无状态相对于它们所使用的服务器的客户端。 但是，如果应用程序必须维护会话状态，存储敏感数据或每个客户机数据的大容量应用程序的所有实例都可以都访问的分布式服务器端缓存中。
- **优化表的存储架构**。 使用表格存储需要的表名和列名传递和处理与每个查询，例如 Azure 表存储时考虑使用较短的名称，以减少这一开销。 但是，不要牺牲可读性或可管理性使用过于紧凑的名称。
- **使用任务并行库 (TPL) 执行异步操作**。 TPL 容易编写异步代码来执行 O 绑定操作。 只要有可能，消除特定的同步上下文上延续的从属关系，请使用_ConfigureAwait(false)_ 。 这将减少发生线程死锁的可能性。
- **在配置过程中或在应用程序启动时创建资源依存关系**。 避免重复的调用方法来测试存在的资源，然后创建资源，如果它不存在。 （如_CloudTable.CreateIfNotExists_和_CloudQueue.CreateIfNotExists_在 Azure 存储客户端库的方法遵循这种模式）。 如果在每个访问存储表或存储队列之前调用它们，这些方法可以施加相当大的开销。 改为︰
 - 当部署应用程序时，或者当它第一次启动创建所需的资源 （一次_CreateIfNotExists_对每个资源在 web 或辅助角色的启动代码是可接受的）。 但是，一定要处理，如果您的代码试图访问不存在的资源可能会产生异常。 在这些情况下，应记录异常，并可能是提醒操作员资源的缺失。
 - 在某些情况下可能是异常的适当处理代码的一部分创建缺少的资源。 但应该采用谨慎使用这种方法，因为该资源不存在可能表明编程错误 （拼写错误的资源示例名称） 或其他基础设施层级问题。
- **使用轻量级框架**。 仔细选择的 Api 和框架用于最小化资源使用情况、 执行时间和应用程序的总体负担。 例如，使用 Web API 处理服务请求可以减少应用程序占用的空间，并提高执行速度，但它可能不适合窗口通信基础的附加功能所需的高级情形。
- **将服务帐户的数量降至最低的考虑**。 例如，使用特定的帐户访问资源或连接上, 有限制，或执行的服务更好的地方保持较少的连接。 这种方法是很常见的服务，例如数据库，但它会影响准确地审核原始用户的模拟由于操作的能力。
- 在开发期间，作为一部分的测试例程和最终版本，以确保在应用程序执行，并根据需要缩放之前的**执行性能分析和负载测试**。 此测试应作为生产平台，并具有相同类型相同的硬件类型和数量数据和用户加载，因为它将在生产中遇到。 有关详细信息，请参阅[测试云服务的性能](vs-azure-tools-performance-profiling-cloud-services.md)。
